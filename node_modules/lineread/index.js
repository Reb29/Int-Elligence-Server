module.exports = LineRead;

var fs = require('fs');

function LineRead(file, options) {

    var self = this;

    this.regexp = /^(.+)\n/;
	this.stream = fs.createReadStream(file, options || {});
    this.running = false;
    this.ended = false;
    this.closed = false;
    this.items = new Array;
    this.events = { 
        error: function(err) { throw err },
        item: function() {},
        close: function() {}
    };
    this.start = Date.now();
    this.size = 1;
    this.count = 0;
    this.bytes = 0;

    fs.stat(file, function(err, stat) {
        if(err) self.events.error(err);
        else self.size = stat.size;;
    });

    this.stream.on('error', function(err) {
        self.events.error(err);
    });

    this.stream.on('end', function() {
        data.length && self.items.push(data);
        self.ended = true;
    });

    var data = '', match;
    this.stream.on('data', function(d) {

        self.bytes += d.length;
        data += d.toString();

        while(true) {
            match = data.match(self.regexp);
            if(match === null) break;
            data = data.slice(match.index + match[0].length);
            self.items.push(match[1]);
        }

        if(self.items.length > 10) {
            self.stream.pause();
        }

    });

    this.resume();
}

LineRead.prototype.readiness = function(num) {
    if(num === undefined) num = 1000;
    return Math.round(this.bytes / this.size * num) / num;
}

LineRead.prototype.info = function() {
    return {
        items: this.count,
        speed: Math.round(1000 * this.count / (Date.now() - this.start)),
        bytes: this.bytes
    }
};

LineRead.prototype.on = function(event, fn) {
	this.events[event] = fn;
};

LineRead.prototype.pause = function() {
	if(this.running === false) return;
    this.running = false;
    clearImmediate(this.immediate);
};

LineRead.prototype.resume = function() {
    if(this.running === true) return;
    this.running = true;

    var self = this;

    var loop = function() {

        if(self.items.length > 0) {
            if(self.running === true) {
                self.count++;
                self.events.item(self.items.shift());
                if(self.items.length < 10) {
                    self.stream.resume();
                }
            }
        } else if(self.ended === true) {
            self.running = false;
            self.closed = true;
            return self.events.close();
        }

        if(self.running === true) {
            self.immediate = setImmediate(loop);
        }
    };

    this.immediate = setImmediate(loop);
};

LineRead.prototype.close = function() {
    clearImmediate(this.immediate);
    this.running = false;
    this.closed = true;
    this.resume = function(){};
    this.pause = function(){};
    this.stream.close();
    this.events.close();
};